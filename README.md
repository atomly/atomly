# Beast Backend (WIP)

## TODO

- Mac OS shell scripts.
- Mac OS global dependencies installation requirements (Prisma 2 only - might be a bug).

---

## Installation

### Requirements

- Have Node.js installed.
- Have Docker installed. If you can't install Docker (e.g. Windows 10 Home Edition), you can fall back to Vagrant then installing Docker inside the guest OS as a good alternative among many.
- Have NPM installed.
- Git Bash CLI recommended.

### Installation: TL;DR

1. Git clone this repository.
2. Install all of the dependencies found in the `package.json`.
3. Start and connect the PostgreSQL database on port 5432 running on Docker.
    - [Detailed steps found here.](https://github.com/beast-app/beast-backend/blob/master/database/README.md)
4. Set up the development environmental variables.
    - [More details in the environmental variables.](#Environmental-Variables-File-Template)
5. Synchronize the database with our Entities by executing the `synchronize_typeorm.sh` script.
6. Introspect the database then generate the Prisma schema and client by executing the `generate_prisma_client.sh` script.
7. Once the database is ready, and the Prisma client has been successfuly generated, it is now safe to start the server by running `npm start`.

---

## Scripts & Workflow

### Scripts & Workflow: TL;DR

- If the database schema changes when changing our TypeORM entities (entity directory), execute the `generate_prisma_client.sh` shell script to update our Prisma schema and client.
- Note that for this to work, TypeORM must have synchronized the database before re-generating the client. If for some reason it does not work, execute the `synchronize_typeorm.sh` script.
- If our server's GraphQL schema (`schema.graphql`) changes, we need to regenerate our `GQL` namespace which contains the type definitions for our GraphQL queries, mutations, subscriptions, etc. To do this, execute the `generate_types.sh` shell script to update our Prisma schema and client.

### Overview

There are certain scripts that must be ran after updating certain files. Some of these files are related to the database architecture, and the rest are related to our GraphQL server. There is no need to run any special script when making changes to our server, but when we make changes to our database, it is important to regenerate our GraphQL schema and types so that it matches our database tables/models.

### The Workflow

The database is managed by two layers.

- The first layer is the TypeORM layer, which iterates the database based on the TypeORM entities for each table which also contains the columns and relations to other tables. Not only it manages the database architecture, it also takes care of generating migrations and subscribers separate from the ones generated by Prisma 2.

- The second layer is the Prisma 2 layer. Prisma 2 introspects the databased (managed by TypeORM) and based on the introspection it generates a Prisma schema. Then, based on how the schema looks, a Prisma client will be generated. The prisma client is capable of serving as a context for our resolvers, capable of fetching or mutating data, as well as subscribing to events in a very efficient way without the need of writing data loaders for all of our entities.

### Scripts

Thanks to the TypeORM configuration settings, it is therefore only necessary to recreate the Prisma schema after TypeORM makes changes to our database schema.

If our GraphQL schema is changed, then we need to regenerate our `GQL` namespace which contains the typings for our queries, automatically generated using the `gql2ts` API.

### TypeORM Synchronize

[Source.](https://github.com/typeorm/typeorm/blob/master/docs/connection-options.md)

> Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. As an alternative to it, you can use CLI and run schema:sync command, or execute the `synchronize_typeorm.sh` script located inside the `scripts` directory.

Whenever this option is set to `true` inside the `ormconfig.js` file, our database schema will be recreated after every change, thanks to `nodemon` detecting any of the changes and restarting the server.

### Prisma Generate

[Source.](https://www.prisma.io/docs/prisma-cli-and-configuration/cli-command-reference/prisma-generate-xcv2/)

> In order to use Prisma Client JS in your application, you must install the @prisma/client package in your application:
> ```npm install @prisma/client```
> The @prisma/client package itself is a facade package (basically a stub) that doesn't contain any functional code, such as types or the Prisma Client JS runtime. When installing the @prisma/client package, its postinstall hook is being executed to invoke the prisma2 generate command and generate the actual Prisma Client JS code into the facade package at node_modules/@prisma/client.
> This means the prisma2 CLI needs to be available as well. It is typically installed as a development dependency:
> ```npm install prisma2 --save-dev```
> Note that you'll need to re-execute prisma2 generate whenever you make changes to your Prisma schema (or perform the changes while are you're running Prisma's development mode.

In short, everytime there are changes to our TypeORM database schema, we need to introspect the database with Prisma 2 to update our Prisma schema, then regenerate our client.

To do this, the script `generate_prisma_client.sh` found in the `scripts` directory is of big help. Simply running `source generate_prisma.sh` in our root folder will automatically introspect then regenerate our Prisma schema and client.

### GrahpQL Schema and Types

To generate GraphQL types base on our schema, if the server's GraphQL schema is changed, execute the `generate_types.sh` shell script to update the `GQL` namespace containing the type definitions of our queries, mutations, subscriptions, etc.

Changes to our actual GraphQL schema will have to be done manually. **It's important to regenerate our types after we change our server's GraphQL schema**. This decision was made with the reasoning that it's important to invest detailed attention into the server's GrapQL schema. This schema is found in the `schema.graphql` file inside the `src/schema` diretory.

---

## Environmental Variables File Template

The following configuration is necessary to run the application. The following env. variables are working examples, make sure to fill them with the valid host IP and port where your local database is hosted, as well as the user. It's possible to add a cloud-hosted database as well.

```.env
# Node #
NODE_PATH=./
NODE_ENV=development
TS_NODE_FILES=true

# TypeORM #
TYPEORM_CONNECTION = postgres
TYPEORM_HOST = 192.168.99.101
TYPEORM_PORT = 5432
TYPEORM_USERNAME = postgres
TYPEORM_PASSWORD = password
TYPEORM_DATABASE = test

# Prisma #
# postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
POSTGRESQL_URL=postgresql://postgres:password@192.168.99.101:5432/test
```
