// Dependencies
import { $$asyncIterator } from 'iterall';

// Types
import { IHubfulService } from '../hub';
import { ISubscriberServiceSubscribeOptions } from '../subscribers';
import { TStorageServicePayload } from '../storages';
import { IAsyncIterator } from './AsyncIterator';

/**
 * A class for digesting Hubful topic payloadss via the IAsyncIterator interface.
 * [This implementation is a generic version of this one](https://github.com/apollographql/graphql-subscriptions/blob/master/src/topic-emitter-to-async-iterator.ts).
 * [Based on this implementation](https://github.com/davidyaha/graphql-redis-subscriptions/blob/master/src/pubsub-async-iterator.ts).
 */
export class HubfulAsyncIterator<T = TStorageServicePayload> implements IAsyncIterator<T> {
  /**
   * A queue of resolve functions waiting for an incoming topic payload which has not yet arrived.
   * This queue expands as next() calls are made without Hubful topic payloads arriving in between.
   */
  public pullQueue: Function[];
  /**
   * A queue of Hubful topics waiting for next() calls to be made.
   * This queue expands as Hubful topics arrive without next() calls occurring in between.
   */
  public pushQueue: T[];
  /**
   * An array of Hubful topics which this AsyncIterator should watch.
   */
  public topicsArray: string[];
  /**
   * A list of all subscription IDs generated by this AsyncIterator.
   */
  public subscriptionIds: string[] | undefined;
  /**
   * Whether or not the AsynIterator is in listening mode (responding to
   * incoming Hubful topic payloads and next() calls).
   * Listening begins as `true` and `turns` to false once the return method is called.
   */
  public isListening: boolean;
  /**
   * The Hubful instance whose topics will be observed.
   */
  public hubful: IHubfulService;
  /**
   * Subscriber Service (`subscribe`) options to filter topics if desired.
   */
  public options?: ISubscriberServiceSubscribeOptions;

  constructor(args: {
    hubful: IHubfulService,
    topics: string | string[],
    options?: ISubscriberServiceSubscribeOptions,
  }) {
    const { hubful, topics, options } = args;
    this.hubful = hubful;
    this.options = options;
    // TODO: Implement a Queue data structure to avoid using `shift` and
    // other inefficient Array methods which re-index all values.
    this.pullQueue = [];
    // TODO: Implement a Queue data structure to avoid using `shift` and
    // other inefficient Array methods which re-index all values.
    this.pushQueue = [];
    this.isListening = true;
    this.topicsArray = typeof topics === 'string' ? [topics] : topics;
  }

  public [$$asyncIterator](): HubfulAsyncIterator<T> {
    return this;
  }
  
  //
  // AsyncIterator methods
  //

  public async next(): Promise<IteratorResult<T>> {
    if (!this.subscriptionIds) { await this.subscribeAll(); }
    return this.isListening ? this.pullValue() : this.return();
  }

  public async return(): Promise<IteratorResult<T>> {
    await this.emptyQueue();
    return { value: undefined, done: true };
  }

  public async throw(error: Error): Promise<IteratorResult<T>> {
    await this.emptyQueue();
    return Promise.reject(error);
  }
  
  //
  // HubfulAsyncIterator methods
  //

  /**
   * Handles incoming payloads from the HubfulService, if the `pullQueue`
   * is empty, it will push the value into the `pushQueue`.
   * Otherwise, the payload is sent to the first `pullQueue` resolve
   * function waiting for a payload.
   * @param _ - Topic name, not used.
   * @param payload - Published payload of the subscribed topic.
   */
  public async pushValue(_: string, payload: T): Promise<void> {
    if (!this.subscriptionIds) { await this.subscribeAll(); }
    if (this.pullQueue.length !== 0) {
      const resolve = this.pullQueue.shift();
      if (resolve) {
        resolve(this.isListening ?
          { value: payload, done: false } :
          { value: undefined, done: true },  
        );
      }
    } else {
      this.pushQueue.push(payload);
    }
  }

  /**
   * Resolves and pushes `T` values from the `pushQueue`.
   * If there are values in the `pushQueue`, it will pull out the oldest payload
   * and resolve it.
   * Otherwise, it will push the resolve function to the `pullQueue` while it waits
   * for the payload.
   */
  public pullValue(): Promise<IteratorResult<T>> {
    return new Promise(resolve => {
      if (this.pushQueue.length !== 0) {
        const payload = this.pushQueue.shift()!;
        resolve(this.isListening ?
          { value: payload, done: false } :
          { value: undefined, done: true },
        );
      } else {
        // TODO: If the promise is never resolved, and the code is "awaited" in runtime,
        // it will result in the process timing out. How to deal with this edge case??
        this.pullQueue.push(resolve);
      }
    });
  }

  /**
   * Stops listening for new payloads, unsubscribes all of the stored `subscriptionIds`,
   * and empties all queues.
   */
  public async emptyQueue(): Promise<void> {
    if (this.isListening) {
      this.isListening = false;
      this.pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));
      this.pullQueue.length = 0;
      this.pushQueue.length = 0;
      if (this.subscriptionIds) { this.unsubscribeAll(this.subscriptionIds); }
    }
  }

  /**
   * Subscribes to all of the received topics in the constructor stored in `topicsArray`.
   * The `pushValue` function will handle the topic events and incoming respective payloads.
   * It returns an array of all of the subscription IDs.
   */
  public async subscribeAll(): Promise<string[]> {
    if (!this.subscriptionIds) {
      this.subscriptionIds = await Promise.all(this.topicsArray.map(topic => (
        this.hubful.subscribe(topic, this.pushValue.bind(this), this.options)
      )));
    }
    return this.subscriptionIds;
  }

  /**
   * Array of subscription IDs that are needed to unsubscribe the topics.
   * @param subscriptionIds - Array of subscriptions IDs.
   */
  public async unsubscribeAll(subscriptionIds: string[] | undefined = this.subscriptionIds): Promise<void> {
    if (subscriptionIds) {
      await Promise.all(subscriptionIds.map(subscriptionId => this.hubful.unsubscribe(subscriptionId)));
    }
  }

}
